<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>JS 获取图片主题色</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      min-height: 100vh;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f5f5f5;
      transition: background 0.6s ease;
    }
    .demo {
      width: min(520px, 90vw);
      text-align: center;
      padding: 24px;
      border-radius: 20px;
      background: rgba(255, 255, 255, 0.9);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.12);
    }
    .demo img {
      width: 100%;
      border-radius: 12px;
      display: block;
      margin-bottom: 24px;
    }
    .result {
      display: flex;
      align-items: center;
      gap: 16px;
      justify-content: center;
    }
    .values {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 4px;
    }
    .swatch {
      width: 64px;
      height: 64px;
      border-radius: 12px;
      border: 1px solid rgba(0, 0, 0, 0.1);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.6);
    }
    .color-value {
      font-size: 1rem;
      font-weight: 600;
      color: #333;
    }
  </style>
</head>
<body>
  <main class="demo">
    <img
      id="source-image"
      src="https://cdn.ailearning.qq.com/teaching-resources/course/20250805/1754328036623527_1-1.jpg"
      alt="示例图片"
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />
    <div class="result">
      <div class="swatch" id="color-swatch"></div>
      <div class="values">
        <p class="color-value" id="color-text">解析中…</p>
        <p class="color-value" id="hsb-text">HSB 解析中…</p>
      </div>
    </div>
  </main>
  <script>
    const img = document.getElementById('source-image');
    const swatch = document.getElementById('color-swatch');
    const colorText = document.getElementById('color-text');
    const hsbText = document.getElementById('hsb-text');
    const MAX_DRAW_DIMENSION = 240;
    const BUCKET_SIZE = 24;

    // 防止后续动态换图遗漏跨域配置
    img.crossOrigin = 'anonymous';
    img.referrerPolicy = 'no-referrer';

    const rgbToHex = (r, g, b) =>
      '#' + [r, g, b].map(channel => channel.toString(16).padStart(2, '0')).join('');

    const rgbToHsb = (r, g, b) => {
      const rn = r / 255;
      const gn = g / 255;
      const bn = b / 255;
      const max = Math.max(rn, gn, bn);
      const min = Math.min(rn, gn, bn);
      const delta = max - min;

      let h = 0;
      if (delta !== 0) {
        if (max === rn) {
          h = ((gn - bn) / delta) % 6;
        } else if (max === gn) {
          h = (bn - rn) / delta + 2;
        } else {
          h = (rn - gn) / delta + 4;
        }
        h = Math.round(h * 60);
        if (h < 0) h += 360;
      }

      const s = max === 0 ? 0 : delta / max;
      const v = max;
      return {
        h,
        s: Math.round(s * 100),
        b: Math.round(v * 100),
      };
    };

    const clamp = (value, min, max) => Math.max(min, Math.min(max, value));

    const getPixelScore = (r, g, b) => {
      const { s, b: brightness } = rgbToHsb(r, g, b);
      const saturationScore = s / 100;
      const preferredBrightness = 1 - Math.abs(brightness - 65) / 65;
      const brightnessScore = clamp(preferredBrightness, 0, 1);
      return saturationScore * 0.7 + brightnessScore * 0.3;
    };

    const computeDominantColor = data => {
      const buckets = new Map();

      for (let i = 0; i < data.length; i += 4) {
        const alpha = data[i + 3];
        if (alpha < 128) continue;
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];

        const score = getPixelScore(r, g, b);
        if (score <= 0) continue;

        const key = [
          Math.round(r / BUCKET_SIZE),
          Math.round(g / BUCKET_SIZE),
          Math.round(b / BUCKET_SIZE),
        ].join('-');

        let bucket = buckets.get(key);
        if (!bucket) {
          bucket = { r: 0, g: 0, b: 0, count: 0, score: 0 };
          buckets.set(key, bucket);
        }

        bucket.r += r;
        bucket.g += g;
        bucket.b += b;
        bucket.count += 1;
        bucket.score += score;
      }

      if (!buckets.size) {
        return null;
      }

      let bestBucket = null;
      let bestWeight = -Infinity;
      buckets.forEach(bucket => {
        const weight = bucket.score * (1 + Math.log(bucket.count + 1));
        if (weight > bestWeight) {
          bestWeight = weight;
          bestBucket = bucket;
        }
      });

      if (!bestBucket || bestBucket.count === 0) {
        return null;
      }

      return {
        r: Math.round(bestBucket.r / bestBucket.count),
        g: Math.round(bestBucket.g / bestBucket.count),
        b: Math.round(bestBucket.b / bestBucket.count),
      };
    };

    const getImageDataSafe = (ctx, width, height) => {
      try {
        return ctx.getImageData(0, 0, width, height);
      } catch (error) {
        if (error.name === 'SecurityError') {
          throw new Error('跨域限制：目标图片未正确设置 CORS');
        }
        throw error;
      }
    };

    const updateThemeColor = () => {
      const canvas = document.createElement('canvas');
      const sourceWidth = img.naturalWidth || img.width;
      const sourceHeight = img.naturalHeight || img.height;

      if (!sourceWidth || !sourceHeight) {
        colorText.textContent = '未获取到图片尺寸';
        hsbText.textContent = 'HSB 暂不可用';
        return;
      }

      const longestSide = Math.max(sourceWidth, sourceHeight);
      const scale = longestSide > MAX_DRAW_DIMENSION ? MAX_DRAW_DIMENSION / longestSide : 1;
      const width = Math.max(1, Math.round(sourceWidth * scale));
      const height = Math.max(1, Math.round(sourceHeight * scale));

      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, width, height);

      let imageData;
      try {
        imageData = getImageDataSafe(ctx, width, height);
      } catch (error) {
        colorText.textContent = error.message;
        hsbText.textContent = 'HSB 暂不可用';
        return;
      }

      const dominantColor = computeDominantColor(imageData.data);
      if (!dominantColor) {
        colorText.textContent = '未识别到有效像素';
        hsbText.textContent = 'HSB 暂不可用';
        return;
      }

      const { r, g, b } = dominantColor;
      const hex = rgbToHex(r, g, b);
      const { h, s, b: brightness } = rgbToHsb(r, g, b);

      swatch.style.backgroundColor = hex;
      colorText.textContent = `${hex} | rgb(${r}, ${g}, ${b})`;
      hsbText.textContent = `hsb(${h}, ${s}%, ${brightness}%)`;
      document.body.style.background = `linear-gradient(135deg, ${hex}, #f5f5f5 70%)`;
    };

    if (img.complete && img.naturalWidth) {
      updateThemeColor();
    } else {
      img.addEventListener('load', updateThemeColor);
      img.addEventListener('error', () => {
        colorText.textContent = '图片加载失败';
        hsbText.textContent = 'HSB 暂不可用';
      });
    }
  </script>
</body>
</html>
